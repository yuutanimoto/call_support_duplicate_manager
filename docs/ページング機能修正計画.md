# ページング機能修正計画

## 1. 現状の問題点と影響範囲

### 1.1 検索・フィルター実行時の問題
- **自動スクロール設定が反映されない**: TableManagerの設定値を参照していない
- **手動ページング不可**: 自動スクロールが動作しない場合、次のデータへアクセス不可
- **位置情報不明**: 現在表示中のデータ範囲が不明

### 1.2 重複検出実行時の問題
- **ページング完全無効**: `isDuplicateMode = true`時、すべてのページング機能が停止
- **500件制限**: ハードコードされた制限により、500件を超える重複データが表示されない
- **手動ページング不可**: 重複データも大量になる可能性があるが、ページング手段なし

### 1.3 影響を受ける機能
- データ表示（`renderTable()`）
- データ読み込み（`loadData()`, `loadMoreData()`）
- 重複検出（`detectDuplicates()`, `displayDuplicates()`）
- 選択機能（全選択・解除）
- 削除・復元機能
- 統計表示

## 2. 修正方針

### 2.1 基本設計方針
1. **モード独立性**: 通常モードと重複モードでそれぞれ独立したページング管理
2. **設定反映**: TableManagerの自動スクロール設定を確実に反映
3. **手動制御**: 両モードで手動ページング機能を提供
4. **状態表示**: 現在の表示範囲を明確に表示

### 2.2 アーキテクチャ変更
```javascript
// 新しい状態管理構造
class DuplicateManagementApp {
    // 通常モード用
    normalModeState = {
        currentData: [],
        totalCount: 0,
        currentPage: 1,
        pageSize: 100,
        hasMore: false,
        offset: 0
    };
    
    // 重複モード用
    duplicateModeState = {
        currentData: [],
        totalCount: 0,
        currentPage: 1,
        pageSize: 100,
        hasMore: false,
        offset: 0,
        allDuplicateData: [],  // 全重複データを保持
        duplicateType: null
    };
}
```

## 3. 詳細実装計画

### 3.1 フェーズ1: 自動スクロール設定の反映

#### 3.1.1 app.jsの修正
```javascript
// setupAutoScroll()メソッドの修正
setupAutoScroll() {
    const tableContainer = document.getElementById("table-container");
    
    tableContainer.addEventListener("scroll", () => {
        // TableManagerの設定を確認
        const isAutoScrollEnabled = this.tableManager?.settings?.autoScroll ?? true;
        
        if (!isAutoScrollEnabled) return;  // 無効時は処理しない
        
        // 重複モードでも条件付きで動作させる
        if (this.isLoading) return;
        
        const { scrollTop, scrollHeight, clientHeight } = tableContainer;
        const threshold = 200;
        
        if (scrollTop + clientHeight >= scrollHeight - threshold) {
            if (this.displayMode === 'normal') {
                this.loadMoreData();
            } else {
                this.loadMoreDuplicateData();  // 新規追加
            }
        }
    });
}
```

### 3.2 フェーズ2: 手動ページングUIの追加

#### 3.2.1 HTML構造の追加（index.html）
```html
<!-- ページネーションコントロール -->
<div class="pagination-controls" id="pagination-controls">
    <div class="pagination-info">
        <span id="pagination-text">全0件中 0-0件を表示</span>
    </div>
    <div class="pagination-buttons">
        <button id="first-page-btn" class="pagination-btn" disabled>
            <i class="fas fa-angle-double-left"></i> 最初
        </button>
        <button id="prev-page-btn" class="pagination-btn" disabled>
            <i class="fas fa-angle-left"></i> 前へ
        </button>
        <span class="page-number">
            ページ <span id="current-page">1</span> / <span id="total-pages">1</span>
        </span>
        <button id="next-page-btn" class="pagination-btn" disabled>
            次へ <i class="fas fa-angle-right"></i>
        </button>
        <button id="last-page-btn" class="pagination-btn" disabled>
            最後 <i class="fas fa-angle-double-right"></i>
        </button>
    </div>
</div>
```

#### 3.2.2 CSS追加（style.css）
```css
.pagination-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background-color: var(--light-color);
    border-top: 1px solid var(--border-color);
}

.pagination-info {
    color: var(--secondary-color);
    font-size: 0.875rem;
}

.pagination-buttons {
    display: flex;
    gap: 0.5rem;
    align-items: center;
}

.pagination-btn {
    padding: 0.5rem 1rem;
    background-color: white;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
}

.pagination-btn:hover:not(:disabled) {
    background-color: var(--primary-color);
    color: white;
}

.pagination-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.page-number {
    padding: 0 1rem;
    font-weight: 500;
}
```

### 3.3 フェーズ3: 通常モードのページング実装

#### 3.3.1 ページング状態管理
```javascript
// app.jsに追加
initializePagination() {
    this.pagination = {
        currentPage: 1,
        totalPages: 1,
        pageSize: 100,
        totalCount: 0,
        startIndex: 0,
        endIndex: 0
    };
}

updatePaginationInfo() {
    const pageSize = this.getPageSize();
    this.pagination.pageSize = pageSize;
    this.pagination.totalPages = Math.ceil(this.totalCount / pageSize);
    this.pagination.startIndex = (this.pagination.currentPage - 1) * pageSize + 1;
    this.pagination.endIndex = Math.min(
        this.pagination.currentPage * pageSize,
        this.totalCount
    );
    
    // UI更新
    this.updatePaginationUI();
}

updatePaginationUI() {
    const paginationText = document.getElementById("pagination-text");
    const currentPageSpan = document.getElementById("current-page");
    const totalPagesSpan = document.getElementById("total-pages");
    
    if (this.totalCount === 0) {
        paginationText.textContent = "データがありません";
    } else {
        paginationText.textContent = 
            `全${this.totalCount}件中 ${this.pagination.startIndex}-${this.pagination.endIndex}件を表示`;
    }
    
    currentPageSpan.textContent = this.pagination.currentPage;
    totalPagesSpan.textContent = this.pagination.totalPages;
    
    // ボタンの有効/無効制御
    this.updatePaginationButtons();
}

updatePaginationButtons() {
    const firstBtn = document.getElementById("first-page-btn");
    const prevBtn = document.getElementById("prev-page-btn");
    const nextBtn = document.getElementById("next-page-btn");
    const lastBtn = document.getElementById("last-page-btn");
    
    firstBtn.disabled = this.pagination.currentPage === 1;
    prevBtn.disabled = this.pagination.currentPage === 1;
    nextBtn.disabled = this.pagination.currentPage === this.pagination.totalPages;
    lastBtn.disabled = this.pagination.currentPage === this.pagination.totalPages;
}
```

#### 3.3.2 ページ遷移機能
```javascript
// ページ遷移メソッド
async goToPage(pageNumber) {
    if (pageNumber < 1 || pageNumber > this.pagination.totalPages) return;
    
    this.pagination.currentPage = pageNumber;
    const offset = (pageNumber - 1) * this.pagination.pageSize;
    
    if (this.displayMode === 'normal') {
        await this.loadData(offset, false);
    } else {
        await this.loadDuplicateDataPage(offset);
    }
}

async goToFirstPage() {
    await this.goToPage(1);
}

async goToPrevPage() {
    await this.goToPage(this.pagination.currentPage - 1);
}

async goToNextPage() {
    await this.goToPage(this.pagination.currentPage + 1);
}

async goToLastPage() {
    await this.goToPage(this.pagination.totalPages);
}
```

### 3.4 フェーズ4: 重複モードのページング実装

#### 3.4.1 重複データのページング対応
```javascript
// 重複データ表示の改修
async displayDuplicates(duplicateData) {
    // 全データを保持
    this.duplicateAllData = [];
    duplicateData.duplicates.forEach(group => {
        group.records.forEach(record => {
            record.duplicate_group = group.group_id;
            this.duplicateAllData.push(record);
        });
    });
    
    this.totalCount = this.duplicateAllData.length;
    this.isDuplicateMode = true;
    
    // ページング初期化
    this.pagination.currentPage = 1;
    this.pagination.totalCount = this.totalCount;
    this.updatePaginationInfo();
    
    // 最初のページを表示
    this.displayDuplicatePage(0);
}

displayDuplicatePage(offset) {
    const pageSize = this.pagination.pageSize;
    const startIdx = offset;
    const endIdx = Math.min(offset + pageSize, this.duplicateAllData.length);
    
    this.currentData = this.duplicateAllData.slice(startIdx, endIdx);
    this.currentOffset = offset;
    this.hasMore = endIdx < this.duplicateAllData.length;
    
    this.renderTable();
    this.updateCounts();
    this.updatePaginationUI();
}

async loadMoreDuplicateData() {
    if (!this.hasMore || this.isLoading) return;
    
    this.isLoading = true;
    try {
        const newOffset = this.currentOffset + this.pagination.pageSize;
        this.displayDuplicatePage(newOffset);
        this.pagination.currentPage++;
        this.updatePaginationUI();
    } finally {
        this.isLoading = false;
    }
}

async loadDuplicateDataPage(offset) {
    this.displayDuplicatePage(offset);
}
```

### 3.5 フェーズ5: イベントリスナーの設定

#### 3.5.1 ページングボタンのイベント設定
```javascript
// setupEventListeners()に追加
setupPaginationEvents() {
    // ページングボタン
    document.getElementById("first-page-btn").addEventListener("click", () => {
        this.goToFirstPage();
    });
    
    document.getElementById("prev-page-btn").addEventListener("click", () => {
        this.goToPrevPage();
    });
    
    document.getElementById("next-page-btn").addEventListener("click", () => {
        this.goToNextPage();
    });
    
    document.getElementById("last-page-btn").addEventListener("click", () => {
        this.goToLastPage();
    });
    
    // ページサイズ変更時の処理
    document.getElementById("page-size").addEventListener("change", () => {
        this.pagination.currentPage = 1;  // 最初のページに戻る
        this.loadData(0, false);
    });
}
```

## 4. テスト計画

### 4.1 通常モードのテスト
1. 自動スクロールのON/OFF切り替え
2. 手動ページング（前へ/次へ/最初/最後）
3. ページサイズ変更時の動作
4. フィルター適用時のページリセット
5. データ削除/復元時のページ維持

### 4.2 重複モードのテスト
1. 重複検出実行時のページング初期化
2. 大量重複データ（500件以上）の表示
3. 重複タイプ切り替え時の動作
4. 通常モードへの復帰時の状態

### 4.3 相互作用のテスト
1. モード切り替え時の状態保持
2. 選択状態の維持
3. 統計情報の更新
4. エラーハンドリング

## 5. リスクと対策

### 5.1 パフォーマンスリスク
- **リスク**: 重複データ全件をメモリに保持
- **対策**: 必要に応じてサーバーサイドページングを検討

### 5.2 互換性リスク
- **リスク**: 既存機能への影響
- **対策**: 段階的な実装とテスト

### 5.3 UXリスク
- **リスク**: 操作の複雑化
- **対策**: 直感的なUI設計とツールチップの追加

## 6. 実装優先順位

1. **優先度1（必須）**
   - 自動スクロール設定の反映
   - 手動ページングUI追加
   - 通常モードのページング

2. **優先度2（重要）**
   - 重複モードのページング
   - ページ情報表示

3. **優先度3（推奨）**
   - キーボードショートカット
   - ページジャンプ機能